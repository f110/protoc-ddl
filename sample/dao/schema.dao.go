// Package dao contains the data access object.
// Generated by protoc-ddl.
// protoc-gen-dao: v0.1
package dao

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"go.f110.dev/protoc-ddl/sample"
)

type ListOption func(opt *listOpt)

func Limit(limit int) func(opt *listOpt) {
	return func(opt *listOpt) {
		opt.limit = limit
	}
}

func Desc(opt *listOpt) {
	opt.desc = true
}

func Sort(col string) func(*listOpt) {
	return func(opt *listOpt) {
		opt.sort = col
	}
}

type listOpt struct {
	sort  string
	limit int
	desc  bool
}

func newListOpt(opts ...ListOption) *listOpt {
	opt := &listOpt{}
	for _, v := range opts {
		v(opt)
	}
	return opt
}

type ExecOption func(opt *execOpt)

func WithTx(tx *sql.Tx) ExecOption {
	return func(opt *execOpt) {
		opt.tx = tx
	}
}

type execOpt struct {
	tx *sql.Tx
}

func newExecOpt(opts ...ExecOption) *execOpt {
	opt := &execOpt{}
	for _, v := range opts {
		v(opt)
	}
	return opt
}

type execConn interface {
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
}

type User struct {
	conn *sql.DB
}

type UserInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*sample.User, error)
	SelectMulti(ctx context.Context, id ...int32) ([]*sample.User, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*sample.User, error)
	ListOverTwenty(ctx context.Context, opt ...ListOption) ([]*sample.User, error)
	Create(ctx context.Context, user *sample.User, opt ...ExecOption) (*sample.User, error)
	Update(ctx context.Context, user *sample.User, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ UserInterface = &User{}

func NewUser(conn *sql.DB) *User {
	return &User{
		conn: conn,
	}
}

func (d *User) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		if rErr := tx.Rollback(); rErr != nil {
			return rErr
		}
		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (d *User) Select(ctx context.Context, id int32) (*sample.User, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `users` WHERE `id` = ?", id)

	v := &sample.User{}
	if err := row.Scan(&v.Id, &v.Age, &v.Name, &v.Title, &v.LastName, &v.Status, &v.CreatedAt); err != nil {
		return nil, err
	}

	v.ResetMark()
	return v, nil
}

func (d *User) SelectMulti(ctx context.Context, id ...int32) ([]*sample.User, error) {
	inCause := strings.Repeat("?, ", len(id))
	args := make([]any, len(id))
	for i := 0; i < len(id); i++ {
		args[i] = id[i]
	}
	rows, err := d.conn.QueryContext(ctx, fmt.Sprintf("SELECT * FROM `users` WHERE `id` IN (%s)", inCause[:len(inCause)-2]), args...)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.User, 0, len(id))
	for rows.Next() {
		r := &sample.User{}
		if err := rows.Scan(&r.Id, &r.Age, &r.Name, &r.Title, &r.LastName, &r.Status, &r.CreatedAt); err != nil {
			return nil, err
		}
		res = append(res, r)
	}

	return res, nil
}

func (d *User) ListAll(ctx context.Context, opt ...ListOption) ([]*sample.User, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `age`, `name`, `title`, `last_name`, `status`, `created_at` FROM `users`"
	orderCol := "`" + listOpts.sort + "`"
	if listOpts.sort == "" {
		orderCol = "`id`"
	}
	orderDi := "ASC"
	if listOpts.desc {
		orderDi = "DESC"
	}
	query = query + fmt.Sprintf(" ORDER BY %s %s", orderCol, orderDi)
	if listOpts.limit > 0 {
		query = query + fmt.Sprintf(" LIMIT %d", listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.User, 0)
	for rows.Next() {
		r := &sample.User{}
		if err := rows.Scan(&r.Id, &r.Age, &r.Name, &r.Title, &r.LastName, &r.Status, &r.CreatedAt); err != nil {
			return nil, err
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *User) ListOverTwenty(ctx context.Context, opt ...ListOption) ([]*sample.User, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `age`, `name`, `title`, `last_name`, `status`, `created_at` FROM `users` WHERE `age` > 20"
	orderCol := "`" + listOpts.sort + "`"
	if listOpts.sort == "" {
		orderCol = "`id`"
	}
	orderDi := "ASC"
	if listOpts.desc {
		orderDi = "DESC"
	}
	query = query + fmt.Sprintf(" ORDER BY %s %s", orderCol, orderDi)
	if listOpts.limit > 0 {
		query = query + fmt.Sprintf(" LIMIT %d", listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.User, 0)
	for rows.Next() {
		r := &sample.User{}
		if err := rows.Scan(&r.Id, &r.Age, &r.Name, &r.Title, &r.LastName, &r.Status, &r.CreatedAt); err != nil {
			return nil, err
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *User) Create(ctx context.Context, user *sample.User, opt ...ExecOption) (*sample.User, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `users` (`age`, `name`, `title`, `last_name`, `status`, `created_at`) VALUES (?, ?, ?, ?, ?, ?)",
		user.Age, user.Name, user.Title, user.LastName, user.Status, user.CreatedAt,
	)
	if err != nil {
		return nil, err
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, err
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	user = user.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, err
	}
	user.Id = int32(insertedId)

	user.ResetMark()
	return user, nil
}

func (d *User) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `users` WHERE `id` = ?", id)
	if err != nil {
		return err
	}

	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *User) Update(ctx context.Context, user *sample.User, opt ...ExecOption) error {
	if !user.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := user.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `users` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, user.Id)...,
	)
	if err != nil {
		return err
	}
	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	user.ResetMark()
	return nil
}

type Blog struct {
	conn *sql.DB

	user *User
}

type BlogInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int64) (*sample.Blog, error)
	SelectMulti(ctx context.Context, id ...int64) ([]*sample.Blog, error)
	ListByTitle(ctx context.Context, title string, opt ...ListOption) ([]*sample.Blog, error)
	ListByUserAndCategory(ctx context.Context, userId int32, categoryId int32, opt ...ListOption) ([]*sample.Blog, error)
	SelectByUserAndTitle(ctx context.Context, userId int32, title string) (*sample.Blog, error)
	Create(ctx context.Context, blog *sample.Blog, opt ...ExecOption) (*sample.Blog, error)
	Update(ctx context.Context, blog *sample.Blog, opt ...ExecOption) error
	Delete(ctx context.Context, id int64, opt ...ExecOption) error
}

var _ BlogInterface = &Blog{}

func NewBlog(conn *sql.DB) *Blog {
	return &Blog{
		conn: conn,
		user: NewUser(conn),
	}
}

func (d *Blog) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		if rErr := tx.Rollback(); rErr != nil {
			return rErr
		}
		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (d *Blog) Select(ctx context.Context, id int64) (*sample.Blog, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `blog` WHERE `id` = ?", id)

	v := &sample.Blog{}
	if err := row.Scan(&v.Id, &v.UserId, &v.Title, &v.Body, &v.CategoryId, &v.Attach, &v.EditorId, &v.Sign, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, err
	}

	{
		if rel, _ := d.user.Select(ctx, v.EditorId); rel != nil {
			v.Editor = rel
		}
	}
	{
		if rel, _ := d.user.Select(ctx, v.UserId); rel != nil {
			v.User = rel
		}
	}

	v.ResetMark()
	return v, nil
}

func (d *Blog) SelectMulti(ctx context.Context, id ...int64) ([]*sample.Blog, error) {
	inCause := strings.Repeat("?, ", len(id))
	args := make([]any, len(id))
	for i := 0; i < len(id); i++ {
		args[i] = id[i]
	}
	rows, err := d.conn.QueryContext(ctx, fmt.Sprintf("SELECT * FROM `blog` WHERE `id` IN (%s)", inCause[:len(inCause)-2]), args...)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Blog, 0, len(id))
	for rows.Next() {
		r := &sample.Blog{}
		if err := rows.Scan(&r.Id, &r.UserId, &r.Title, &r.Body, &r.CategoryId, &r.Attach, &r.EditorId, &r.Sign, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, err
		}
		res = append(res, r)
	}

	if len(res) > 0 {
		editorPrimaryKeys := make([]int32, len(res))
		userPrimaryKeys := make([]int32, len(res))
		for i, v := range res {
			editorPrimaryKeys[i] = v.EditorId
			userPrimaryKeys[i] = v.UserId
		}
		editorData := make(map[int32]*sample.User)
		{
			rels, _ := d.user.SelectMulti(ctx, editorPrimaryKeys...)
			for _, v := range rels {
				editorData[v.Id] = v
			}
		}
		userData := make(map[int32]*sample.User)
		{
			rels, _ := d.user.SelectMulti(ctx, userPrimaryKeys...)
			for _, v := range rels {
				userData[v.Id] = v
			}
		}
		for _, v := range res {
			v.Editor = editorData[v.EditorId]
			v.User = userData[v.UserId]
		}
	}
	return res, nil
}

func (d *Blog) ListByTitle(ctx context.Context, title string, opt ...ListOption) ([]*sample.Blog, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `user_id`, `title`, `body`, `category_id`, `attach`, `editor_id`, `sign`, `created_at`, `updated_at` FROM `blog` WHERE `title` = ?"
	orderCol := "`" + listOpts.sort + "`"
	if listOpts.sort == "" {
		orderCol = "`id`"
	}
	orderDi := "ASC"
	if listOpts.desc {
		orderDi = "DESC"
	}
	query = query + fmt.Sprintf(" ORDER BY %s %s", orderCol, orderDi)
	if listOpts.limit > 0 {
		query = query + fmt.Sprintf(" LIMIT %d", listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		title,
	)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Blog, 0)
	for rows.Next() {
		r := &sample.Blog{}
		if err := rows.Scan(&r.Id, &r.UserId, &r.Title, &r.Body, &r.CategoryId, &r.Attach, &r.EditorId, &r.Sign, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, err
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		userPrimaryKeys := make([]int32, len(res))
		editorPrimaryKeys := make([]int32, len(res))
		for i, v := range res {
			userPrimaryKeys[i] = v.UserId
			editorPrimaryKeys[i] = v.EditorId
		}
		userData := make(map[int32]*sample.User)
		{
			rels, _ := d.user.SelectMulti(ctx, userPrimaryKeys...)
			for _, v := range rels {
				userData[v.Id] = v
			}
		}
		editorData := make(map[int32]*sample.User)
		{
			rels, _ := d.user.SelectMulti(ctx, editorPrimaryKeys...)
			for _, v := range rels {
				editorData[v.Id] = v
			}
		}
		for _, v := range res {
			v.User = userData[v.UserId]
			v.Editor = editorData[v.EditorId]
		}
	}

	return res, nil
}

func (d *Blog) ListByUserAndCategory(ctx context.Context, userId int32, categoryId int32, opt ...ListOption) ([]*sample.Blog, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `user_id`, `title`, `body`, `category_id`, `attach`, `editor_id`, `sign`, `created_at`, `updated_at` FROM `blog` WHERE `user_id` = ? AND `category_id` = ?"
	orderCol := "`" + listOpts.sort + "`"
	if listOpts.sort == "" {
		orderCol = "`id`"
	}
	orderDi := "ASC"
	if listOpts.desc {
		orderDi = "DESC"
	}
	query = query + fmt.Sprintf(" ORDER BY %s %s", orderCol, orderDi)
	if listOpts.limit > 0 {
		query = query + fmt.Sprintf(" LIMIT %d", listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		userId,
		categoryId,
	)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Blog, 0)
	for rows.Next() {
		r := &sample.Blog{}
		if err := rows.Scan(&r.Id, &r.UserId, &r.Title, &r.Body, &r.CategoryId, &r.Attach, &r.EditorId, &r.Sign, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, err
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		userPrimaryKeys := make([]int32, len(res))
		editorPrimaryKeys := make([]int32, len(res))
		for i, v := range res {
			userPrimaryKeys[i] = v.UserId
			editorPrimaryKeys[i] = v.EditorId
		}
		userData := make(map[int32]*sample.User)
		{
			rels, _ := d.user.SelectMulti(ctx, userPrimaryKeys...)
			for _, v := range rels {
				userData[v.Id] = v
			}
		}
		editorData := make(map[int32]*sample.User)
		{
			rels, _ := d.user.SelectMulti(ctx, editorPrimaryKeys...)
			for _, v := range rels {
				editorData[v.Id] = v
			}
		}
		for _, v := range res {
			v.User = userData[v.UserId]
			v.Editor = editorData[v.EditorId]
		}
	}

	return res, nil
}

func (d *Blog) SelectByUserAndTitle(ctx context.Context, userId int32, title string) (*sample.Blog, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `id`, `user_id`, `title`, `body`, `category_id`, `attach`, `editor_id`, `sign`, `created_at`, `updated_at` FROM `blog` WHERE `user_id` = ? AND `title` = ?",
		userId,
		title,
	)
	v := &sample.Blog{}
	if err := row.Scan(&v.Id, &v.UserId, &v.Title, &v.Body, &v.CategoryId, &v.Attach, &v.EditorId, &v.Sign, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, err
	}

	{
		if rel, _ := d.user.Select(ctx, v.EditorId); rel != nil {
			v.Editor = rel
		}
	}
	{
		if rel, _ := d.user.Select(ctx, v.UserId); rel != nil {
			v.User = rel
		}
	}

	v.ResetMark()
	return v, nil
}

func (d *Blog) Create(ctx context.Context, blog *sample.Blog, opt ...ExecOption) (*sample.Blog, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `blog` (`user_id`, `title`, `body`, `category_id`, `attach`, `editor_id`, `sign`, `created_at`) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
		blog.UserId, blog.Title, blog.Body, blog.CategoryId, blog.Attach, blog.EditorId, blog.Sign, time.Now(),
	)
	if err != nil {
		return nil, err
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, err
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	blog = blog.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, err
	}
	blog.Id = int64(insertedId)

	blog.ResetMark()
	return blog, nil
}

func (d *Blog) Delete(ctx context.Context, id int64, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `blog` WHERE `id` = ?", id)
	if err != nil {
		return err
	}

	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Blog) Update(ctx context.Context, blog *sample.Blog, opt ...ExecOption) error {
	if !blog.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := blog.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `blog` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, blog.Id)...,
	)
	if err != nil {
		return err
	}
	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	blog.ResetMark()
	return nil
}

type CommentImage struct {
	conn *sql.DB

	comment *Comment
	like    *Like
}

type CommentImageInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, commentBlogId int64, commentUserId int32, likeId uint64) (*sample.CommentImage, error)
	ListByLikeId(ctx context.Context, likeId uint64, opt ...ListOption) ([]*sample.CommentImage, error)
	Create(ctx context.Context, commentImage *sample.CommentImage, opt ...ExecOption) (*sample.CommentImage, error)
	Update(ctx context.Context, commentImage *sample.CommentImage, opt ...ExecOption) error
	Delete(ctx context.Context, commentBlogId int64, commentUserId int32, likeId uint64, opt ...ExecOption) error
}

var _ CommentImageInterface = &CommentImage{}

func NewCommentImage(conn *sql.DB) *CommentImage {
	return &CommentImage{
		conn:    conn,
		comment: NewComment(conn),
		like:    NewLike(conn),
	}
}

func (d *CommentImage) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		if rErr := tx.Rollback(); rErr != nil {
			return rErr
		}
		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (d *CommentImage) Select(ctx context.Context, commentBlogId int64, commentUserId int32, likeId uint64) (*sample.CommentImage, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `comment_image` WHERE `comment_blog_id` = ? AND `comment_user_id` = ? AND `like_id` = ?", commentBlogId, commentUserId, likeId)

	v := &sample.CommentImage{}
	if err := row.Scan(&v.CommentBlogId, &v.CommentUserId, &v.LikeId); err != nil {
		return nil, err
	}

	{
		if rel, _ := d.comment.Select(ctx, v.CommentBlogId, v.CommentUserId); rel != nil {
			v.Comment = rel
		}
	}
	{
		if rel, _ := d.like.Select(ctx, v.LikeId); rel != nil {
			v.Like = rel
		}
	}

	v.ResetMark()
	return v, nil
}

func (d *CommentImage) ListByLikeId(ctx context.Context, likeId uint64, opt ...ListOption) ([]*sample.CommentImage, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `comment_blog_id`, `comment_user_id`, `like_id` FROM `comment_image` WHERE `like_id` = ?"
	orderCol := "`" + listOpts.sort + "`"
	if listOpts.sort == "" {
		orderCol = "`comment_blog_id`,`comment_user_id`,`like_id`"
	}
	orderDi := "ASC"
	if listOpts.desc {
		orderDi = "DESC"
	}
	query = query + fmt.Sprintf(" ORDER BY %s %s", orderCol, orderDi)
	if listOpts.limit > 0 {
		query = query + fmt.Sprintf(" LIMIT %d", listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		likeId,
	)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.CommentImage, 0)
	for rows.Next() {
		r := &sample.CommentImage{}
		if err := rows.Scan(&r.CommentBlogId, &r.CommentUserId, &r.LikeId); err != nil {
			return nil, err
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		likePrimaryKeys := make([]uint64, len(res))
		for i, v := range res {
			likePrimaryKeys[i] = v.LikeId
		}
		likeData := make(map[uint64]*sample.Like)
		{
			rels, _ := d.like.SelectMulti(ctx, likePrimaryKeys...)
			for _, v := range rels {
				likeData[v.Id] = v
			}
		}
		for _, v := range res {
			v.Like = likeData[v.LikeId]
		}

		for _, v := range res {
			{
				if rel, _ := d.comment.Select(ctx, v.CommentBlogId, v.CommentUserId); rel != nil {
					v.Comment = rel
				}
			}
		}
	}

	return res, nil
}

func (d *CommentImage) Create(ctx context.Context, commentImage *sample.CommentImage, opt ...ExecOption) (*sample.CommentImage, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `comment_image` (`comment_blog_id`, `comment_user_id`, `like_id`) VALUES (?, ?, ?)",
		commentImage.CommentBlogId, commentImage.CommentUserId, commentImage.LikeId,
	)
	if err != nil {
		return nil, err
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, err
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	commentImage = commentImage.Copy()

	commentImage.ResetMark()
	return commentImage, nil
}

func (d *CommentImage) Delete(ctx context.Context, commentBlogId int64, commentUserId int32, likeId uint64, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `comment_image` WHERE `comment_blog_id` = ? AND `comment_user_id` = ? AND `like_id` = ?", commentBlogId, commentUserId, likeId)
	if err != nil {
		return err
	}

	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *CommentImage) Update(ctx context.Context, commentImage *sample.CommentImage, opt ...ExecOption) error {
	if !commentImage.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := commentImage.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `comment_image` SET %s WHERE `comment_blog_id` = ? AND `comment_user_id` = ? AND `like_id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, commentImage.CommentBlogId, commentImage.CommentUserId, commentImage.LikeId)...,
	)
	if err != nil {
		return err
	}
	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	commentImage.ResetMark()
	return nil
}

type Comment struct {
	conn *sql.DB

	blog *Blog
	user *User
}

type CommentInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, blogId int64, userId int32) (*sample.Comment, error)
	SelectByUser(ctx context.Context, userId int32) (*sample.Comment, error)
	Create(ctx context.Context, comment *sample.Comment, opt ...ExecOption) (*sample.Comment, error)
	Update(ctx context.Context, comment *sample.Comment, opt ...ExecOption) error
	Delete(ctx context.Context, blogId int64, userId int32, opt ...ExecOption) error
}

var _ CommentInterface = &Comment{}

func NewComment(conn *sql.DB) *Comment {
	return &Comment{
		conn: conn,
		blog: NewBlog(conn),
		user: NewUser(conn),
	}
}

func (d *Comment) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		if rErr := tx.Rollback(); rErr != nil {
			return rErr
		}
		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (d *Comment) Select(ctx context.Context, blogId int64, userId int32) (*sample.Comment, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `comment` WHERE `blog_id` = ? AND `user_id` = ?", blogId, userId)

	v := &sample.Comment{}
	if err := row.Scan(&v.BlogId, &v.UserId); err != nil {
		return nil, err
	}

	{
		if rel, _ := d.blog.Select(ctx, v.BlogId); rel != nil {
			v.Blog = rel
		}
	}
	{
		if rel, _ := d.user.Select(ctx, v.UserId); rel != nil {
			v.User = rel
		}
	}

	v.ResetMark()
	return v, nil
}

func (d *Comment) SelectByUser(ctx context.Context, userId int32) (*sample.Comment, error) {
	row := d.conn.QueryRowContext(
		ctx,
		"SELECT `blog_id`, `user_id` FROM `comment` WHERE `user_id` = ?",
		userId,
	)
	v := &sample.Comment{}
	if err := row.Scan(&v.BlogId, &v.UserId); err != nil {
		return nil, err
	}

	{
		if rel, _ := d.blog.Select(ctx, v.BlogId); rel != nil {
			v.Blog = rel
		}
	}
	{
		if rel, _ := d.user.Select(ctx, v.UserId); rel != nil {
			v.User = rel
		}
	}

	v.ResetMark()
	return v, nil
}

func (d *Comment) Create(ctx context.Context, comment *sample.Comment, opt ...ExecOption) (*sample.Comment, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `comment` (`blog_id`, `user_id`) VALUES (?, ?)",
		comment.BlogId, comment.UserId,
	)
	if err != nil {
		return nil, err
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, err
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	comment = comment.Copy()

	comment.ResetMark()
	return comment, nil
}

func (d *Comment) Delete(ctx context.Context, blogId int64, userId int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `comment` WHERE `blog_id` = ? AND `user_id` = ?", blogId, userId)
	if err != nil {
		return err
	}

	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Comment) Update(ctx context.Context, comment *sample.Comment, opt ...ExecOption) error {
	if !comment.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := comment.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `comment` SET %s WHERE `blog_id` = ? AND `user_id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, comment.BlogId, comment.UserId)...,
	)
	if err != nil {
		return err
	}
	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	comment.ResetMark()
	return nil
}

type Reply struct {
	conn *sql.DB

	comment *Comment
}

type ReplyInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*sample.Reply, error)
	SelectMulti(ctx context.Context, id ...int32) ([]*sample.Reply, error)
	ListByBody(ctx context.Context, body string, opt ...ListOption) ([]*sample.Reply, error)
	Create(ctx context.Context, reply *sample.Reply, opt ...ExecOption) (*sample.Reply, error)
	Update(ctx context.Context, reply *sample.Reply, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ ReplyInterface = &Reply{}

func NewReply(conn *sql.DB) *Reply {
	return &Reply{
		conn:    conn,
		comment: NewComment(conn),
	}
}

func (d *Reply) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		if rErr := tx.Rollback(); rErr != nil {
			return rErr
		}
		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (d *Reply) Select(ctx context.Context, id int32) (*sample.Reply, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `reply` WHERE `id` = ?", id)

	v := &sample.Reply{}
	if err := row.Scan(&v.Id, &v.CommentBlogId, &v.CommentUserId, &v.Body); err != nil {
		return nil, err
	}

	{
		if v.CommentBlogId != nil && v.CommentUserId != nil {
			if rel, _ := d.comment.Select(ctx, *v.CommentBlogId, *v.CommentUserId); rel != nil {
				v.Comment = rel
			}
		}
	}

	v.ResetMark()
	return v, nil
}

func (d *Reply) SelectMulti(ctx context.Context, id ...int32) ([]*sample.Reply, error) {
	inCause := strings.Repeat("?, ", len(id))
	args := make([]any, len(id))
	for i := 0; i < len(id); i++ {
		args[i] = id[i]
	}
	rows, err := d.conn.QueryContext(ctx, fmt.Sprintf("SELECT * FROM `reply` WHERE `id` IN (%s)", inCause[:len(inCause)-2]), args...)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Reply, 0, len(id))
	for rows.Next() {
		r := &sample.Reply{}
		if err := rows.Scan(&r.Id, &r.CommentBlogId, &r.CommentUserId, &r.Body); err != nil {
			return nil, err
		}
		res = append(res, r)
	}

	if len(res) > 0 {

		for _, v := range res {
			{
				if v.CommentBlogId != nil && v.CommentUserId != nil {
					if rel, _ := d.comment.Select(ctx, *v.CommentBlogId, *v.CommentUserId); rel != nil {
						v.Comment = rel
					}
				}
			}
		}
	}
	return res, nil
}

func (d *Reply) ListByBody(ctx context.Context, body string, opt ...ListOption) ([]*sample.Reply, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `comment_blog_id`, `comment_user_id`, `body` FROM `reply` WHERE `body` = ?"
	orderCol := "`" + listOpts.sort + "`"
	if listOpts.sort == "" {
		orderCol = "`id`"
	}
	orderDi := "ASC"
	if listOpts.desc {
		orderDi = "DESC"
	}
	query = query + fmt.Sprintf(" ORDER BY %s %s", orderCol, orderDi)
	if listOpts.limit > 0 {
		query = query + fmt.Sprintf(" LIMIT %d", listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		body,
	)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Reply, 0)
	for rows.Next() {
		r := &sample.Reply{}
		if err := rows.Scan(&r.Id, &r.CommentBlogId, &r.CommentUserId, &r.Body); err != nil {
			return nil, err
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {

		for _, v := range res {
			{
				if v.CommentBlogId != nil && v.CommentUserId != nil {
					if rel, _ := d.comment.Select(ctx, *v.CommentBlogId, *v.CommentUserId); rel != nil {
						v.Comment = rel
					}
				}
			}
		}
	}

	return res, nil
}

func (d *Reply) Create(ctx context.Context, reply *sample.Reply, opt ...ExecOption) (*sample.Reply, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `reply` (`comment_blog_id`, `comment_user_id`, `body`) VALUES (?, ?, ?)",
		reply.CommentBlogId, reply.CommentUserId, reply.Body,
	)
	if err != nil {
		return nil, err
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, err
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	reply = reply.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, err
	}
	reply.Id = int32(insertedId)

	reply.ResetMark()
	return reply, nil
}

func (d *Reply) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `reply` WHERE `id` = ?", id)
	if err != nil {
		return err
	}

	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Reply) Update(ctx context.Context, reply *sample.Reply, opt ...ExecOption) error {
	if !reply.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := reply.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `reply` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, reply.Id)...,
	)
	if err != nil {
		return err
	}
	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	reply.ResetMark()
	return nil
}

type Like struct {
	conn *sql.DB

	blog *Blog
	user *User
}

type LikeInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id uint64) (*sample.Like, error)
	SelectMulti(ctx context.Context, id ...uint64) ([]*sample.Like, error)
	Create(ctx context.Context, like *sample.Like, opt ...ExecOption) (*sample.Like, error)
	Update(ctx context.Context, like *sample.Like, opt ...ExecOption) error
	Delete(ctx context.Context, id uint64, opt ...ExecOption) error
}

var _ LikeInterface = &Like{}

func NewLike(conn *sql.DB) *Like {
	return &Like{
		conn: conn,
		blog: NewBlog(conn),
		user: NewUser(conn),
	}
}

func (d *Like) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		if rErr := tx.Rollback(); rErr != nil {
			return rErr
		}
		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (d *Like) Select(ctx context.Context, id uint64) (*sample.Like, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `like` WHERE `id` = ?", id)

	v := &sample.Like{}
	if err := row.Scan(&v.Id, &v.UserId, &v.BlogId); err != nil {
		return nil, err
	}

	{
		if rel, _ := d.blog.Select(ctx, v.BlogId); rel != nil {
			v.Blog = rel
		}
	}
	{
		if rel, _ := d.user.Select(ctx, v.UserId); rel != nil {
			v.User = rel
		}
	}

	v.ResetMark()
	return v, nil
}

func (d *Like) SelectMulti(ctx context.Context, id ...uint64) ([]*sample.Like, error) {
	inCause := strings.Repeat("?, ", len(id))
	args := make([]any, len(id))
	for i := 0; i < len(id); i++ {
		args[i] = id[i]
	}
	rows, err := d.conn.QueryContext(ctx, fmt.Sprintf("SELECT * FROM `like` WHERE `id` IN (%s)", inCause[:len(inCause)-2]), args...)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Like, 0, len(id))
	for rows.Next() {
		r := &sample.Like{}
		if err := rows.Scan(&r.Id, &r.UserId, &r.BlogId); err != nil {
			return nil, err
		}
		res = append(res, r)
	}

	if len(res) > 0 {
		userPrimaryKeys := make([]int32, len(res))
		blogPrimaryKeys := make([]int64, len(res))
		for i, v := range res {
			userPrimaryKeys[i] = v.UserId
			blogPrimaryKeys[i] = v.BlogId
		}
		userData := make(map[int32]*sample.User)
		{
			rels, _ := d.user.SelectMulti(ctx, userPrimaryKeys...)
			for _, v := range rels {
				userData[v.Id] = v
			}
		}
		blogData := make(map[int64]*sample.Blog)
		{
			rels, _ := d.blog.SelectMulti(ctx, blogPrimaryKeys...)
			for _, v := range rels {
				blogData[v.Id] = v
			}
		}
		for _, v := range res {
			v.User = userData[v.UserId]
			v.Blog = blogData[v.BlogId]
		}
	}
	return res, nil
}

func (d *Like) Create(ctx context.Context, like *sample.Like, opt ...ExecOption) (*sample.Like, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `like` (`user_id`, `blog_id`) VALUES (?, ?)",
		like.UserId, like.BlogId,
	)
	if err != nil {
		return nil, err
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, err
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	like = like.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, err
	}
	like.Id = uint64(insertedId)

	like.ResetMark()
	return like, nil
}

func (d *Like) Delete(ctx context.Context, id uint64, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `like` WHERE `id` = ?", id)
	if err != nil {
		return err
	}

	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Like) Update(ctx context.Context, like *sample.Like, opt ...ExecOption) error {
	if !like.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := like.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `like` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, like.Id)...,
	)
	if err != nil {
		return err
	}
	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	like.ResetMark()
	return nil
}

type PostImage struct {
	conn *sql.DB
}

type PostImageInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*sample.PostImage, error)
	SelectMulti(ctx context.Context, id ...int32) ([]*sample.PostImage, error)
	Create(ctx context.Context, postImage *sample.PostImage, opt ...ExecOption) (*sample.PostImage, error)
	Update(ctx context.Context, postImage *sample.PostImage, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ PostImageInterface = &PostImage{}

func NewPostImage(conn *sql.DB) *PostImage {
	return &PostImage{
		conn: conn,
	}
}

func (d *PostImage) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		if rErr := tx.Rollback(); rErr != nil {
			return rErr
		}
		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (d *PostImage) Select(ctx context.Context, id int32) (*sample.PostImage, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `post_image` WHERE `id` = ?", id)

	v := &sample.PostImage{}
	if err := row.Scan(&v.Id, &v.Url); err != nil {
		return nil, err
	}

	v.ResetMark()
	return v, nil
}

func (d *PostImage) SelectMulti(ctx context.Context, id ...int32) ([]*sample.PostImage, error) {
	inCause := strings.Repeat("?, ", len(id))
	args := make([]any, len(id))
	for i := 0; i < len(id); i++ {
		args[i] = id[i]
	}
	rows, err := d.conn.QueryContext(ctx, fmt.Sprintf("SELECT * FROM `post_image` WHERE `id` IN (%s)", inCause[:len(inCause)-2]), args...)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.PostImage, 0, len(id))
	for rows.Next() {
		r := &sample.PostImage{}
		if err := rows.Scan(&r.Id, &r.Url); err != nil {
			return nil, err
		}
		res = append(res, r)
	}

	return res, nil
}

func (d *PostImage) Create(ctx context.Context, postImage *sample.PostImage, opt ...ExecOption) (*sample.PostImage, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `post_image` (`id`, `url`) VALUES (?, ?)",
		postImage.Id, postImage.Url,
	)
	if err != nil {
		return nil, err
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, err
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	postImage = postImage.Copy()

	postImage.ResetMark()
	return postImage, nil
}

func (d *PostImage) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `post_image` WHERE `id` = ?", id)
	if err != nil {
		return err
	}

	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *PostImage) Update(ctx context.Context, postImage *sample.PostImage, opt ...ExecOption) error {
	if !postImage.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := postImage.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `post_image` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, postImage.Id)...,
	)
	if err != nil {
		return err
	}
	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	postImage.ResetMark()
	return nil
}

type Task struct {
	conn *sql.DB

	postImage *PostImage
}

type TaskInterface interface {
	Tx(ctx context.Context, fn func(tx *sql.Tx) error) error
	Select(ctx context.Context, id int32) (*sample.Task, error)
	SelectMulti(ctx context.Context, id ...int32) ([]*sample.Task, error)
	ListAll(ctx context.Context, opt ...ListOption) ([]*sample.Task, error)
	ListPending(ctx context.Context, opt ...ListOption) ([]*sample.Task, error)
	Create(ctx context.Context, task *sample.Task, opt ...ExecOption) (*sample.Task, error)
	Update(ctx context.Context, task *sample.Task, opt ...ExecOption) error
	Delete(ctx context.Context, id int32, opt ...ExecOption) error
}

var _ TaskInterface = &Task{}

func NewTask(conn *sql.DB) *Task {
	return &Task{
		conn:      conn,
		postImage: NewPostImage(conn),
	}
}

func (d *Task) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {
	tx, err := d.conn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		if rErr := tx.Rollback(); rErr != nil {
			return rErr
		}
		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (d *Task) Select(ctx context.Context, id int32) (*sample.Task, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `task` WHERE `id` = ?", id)

	v := &sample.Task{}
	if err := row.Scan(&v.Id, &v.ImageId, &v.StartAt); err != nil {
		return nil, err
	}

	{
		if rel, _ := d.postImage.Select(ctx, v.ImageId); rel != nil {
			v.Image = rel
		}
	}

	v.ResetMark()
	return v, nil
}

func (d *Task) SelectMulti(ctx context.Context, id ...int32) ([]*sample.Task, error) {
	inCause := strings.Repeat("?, ", len(id))
	args := make([]any, len(id))
	for i := 0; i < len(id); i++ {
		args[i] = id[i]
	}
	rows, err := d.conn.QueryContext(ctx, fmt.Sprintf("SELECT * FROM `task` WHERE `id` IN (%s)", inCause[:len(inCause)-2]), args...)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Task, 0, len(id))
	for rows.Next() {
		r := &sample.Task{}
		if err := rows.Scan(&r.Id, &r.ImageId, &r.StartAt); err != nil {
			return nil, err
		}
		res = append(res, r)
	}

	if len(res) > 0 {
		imagePrimaryKeys := make([]int32, len(res))
		for i, v := range res {
			imagePrimaryKeys[i] = v.ImageId
		}
		imageData := make(map[int32]*sample.PostImage)
		{
			rels, _ := d.postImage.SelectMulti(ctx, imagePrimaryKeys...)
			for _, v := range rels {
				imageData[v.Id] = v
			}
		}
		for _, v := range res {
			v.Image = imageData[v.ImageId]
		}
	}
	return res, nil
}

func (d *Task) ListAll(ctx context.Context, opt ...ListOption) ([]*sample.Task, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `image_id`, `start_at` FROM `task`"
	orderCol := "`" + listOpts.sort + "`"
	if listOpts.sort == "" {
		orderCol = "`id`"
	}
	orderDi := "ASC"
	if listOpts.desc {
		orderDi = "DESC"
	}
	query = query + fmt.Sprintf(" ORDER BY %s %s", orderCol, orderDi)
	if listOpts.limit > 0 {
		query = query + fmt.Sprintf(" LIMIT %d", listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Task, 0)
	for rows.Next() {
		r := &sample.Task{}
		if err := rows.Scan(&r.Id, &r.ImageId, &r.StartAt); err != nil {
			return nil, err
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		imagePrimaryKeys := make([]int32, len(res))
		for i, v := range res {
			imagePrimaryKeys[i] = v.ImageId
		}
		imageData := make(map[int32]*sample.PostImage)
		{
			rels, _ := d.postImage.SelectMulti(ctx, imagePrimaryKeys...)
			for _, v := range rels {
				imageData[v.Id] = v
			}
		}
		for _, v := range res {
			v.Image = imageData[v.ImageId]
		}
	}

	return res, nil
}

func (d *Task) ListPending(ctx context.Context, opt ...ListOption) ([]*sample.Task, error) {
	listOpts := newListOpt(opt...)
	query := "SELECT `id`, `image_id`, `start_at` FROM `task` WHERE `start_at` IS NULL"
	orderCol := "`" + listOpts.sort + "`"
	if listOpts.sort == "" {
		orderCol = "`id`"
	}
	orderDi := "ASC"
	if listOpts.desc {
		orderDi = "DESC"
	}
	query = query + fmt.Sprintf(" ORDER BY %s %s", orderCol, orderDi)
	if listOpts.limit > 0 {
		query = query + fmt.Sprintf(" LIMIT %d", listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, err
	}

	res := make([]*sample.Task, 0)
	for rows.Next() {
		r := &sample.Task{}
		if err := rows.Scan(&r.Id, &r.ImageId, &r.StartAt); err != nil {
			return nil, err
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		imagePrimaryKeys := make([]int32, len(res))
		for i, v := range res {
			imagePrimaryKeys[i] = v.ImageId
		}
		imageData := make(map[int32]*sample.PostImage)
		{
			rels, _ := d.postImage.SelectMulti(ctx, imagePrimaryKeys...)
			for _, v := range rels {
				imageData[v.Id] = v
			}
		}
		for _, v := range res {
			v.Image = imageData[v.ImageId]
		}
	}

	return res, nil
}

func (d *Task) Create(ctx context.Context, task *sample.Task, opt ...ExecOption) (*sample.Task, error) {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(
		ctx,
		"INSERT INTO `task` (`image_id`, `start_at`) VALUES (?, ?)",
		task.ImageId, task.StartAt,
	)
	if err != nil {
		return nil, err
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, err
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	task = task.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, err
	}
	task.Id = int32(insertedId)

	task.ResetMark()
	return task, nil
}

func (d *Task) Delete(ctx context.Context, id int32, opt ...ExecOption) error {
	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	res, err := conn.ExecContext(ctx, "DELETE FROM `task` WHERE `id` = ?", id)
	if err != nil {
		return err
	}

	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Task) Update(ctx context.Context, task *sample.Task, opt ...ExecOption) error {
	if !task.IsChanged() {
		return nil
	}

	execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}

	changedColumn := task.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}

	query := fmt.Sprintf("UPDATE `task` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := conn.ExecContext(
		ctx,
		query,
		append(values, task.Id)...,
	)
	if err != nil {
		return err
	}
	if n, err := res.RowsAffected(); err != nil {
		return err
	} else if n == 0 {
		return sql.ErrNoRows
	}

	task.ResetMark()
	return nil
}
